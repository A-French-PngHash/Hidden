// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'home_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$HomeCubitState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingDefault,
    required TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)
        main,
    required TResult Function(double percentage) computing,
    required TResult Function(Image image) goToResults,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingDefault,
    TResult? Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult? Function(double percentage)? computing,
    TResult? Function(Image image)? goToResults,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingDefault,
    TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult Function(double percentage)? computing,
    TResult Function(Image image)? goToResults,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingDefault value) loadingDefault,
    required TResult Function(_Main value) main,
    required TResult Function(_Computing value) computing,
    required TResult Function(_GoToResults value) goToResults,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadingDefault value)? loadingDefault,
    TResult? Function(_Main value)? main,
    TResult? Function(_Computing value)? computing,
    TResult? Function(_GoToResults value)? goToResults,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingDefault value)? loadingDefault,
    TResult Function(_Main value)? main,
    TResult Function(_Computing value)? computing,
    TResult Function(_GoToResults value)? goToResults,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HomeCubitStateCopyWith<$Res> {
  factory $HomeCubitStateCopyWith(
          HomeCubitState value, $Res Function(HomeCubitState) then) =
      _$HomeCubitStateCopyWithImpl<$Res, HomeCubitState>;
}

/// @nodoc
class _$HomeCubitStateCopyWithImpl<$Res, $Val extends HomeCubitState>
    implements $HomeCubitStateCopyWith<$Res> {
  _$HomeCubitStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_LoadingDefaultCopyWith<$Res> {
  factory _$$_LoadingDefaultCopyWith(
          _$_LoadingDefault value, $Res Function(_$_LoadingDefault) then) =
      __$$_LoadingDefaultCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LoadingDefaultCopyWithImpl<$Res>
    extends _$HomeCubitStateCopyWithImpl<$Res, _$_LoadingDefault>
    implements _$$_LoadingDefaultCopyWith<$Res> {
  __$$_LoadingDefaultCopyWithImpl(
      _$_LoadingDefault _value, $Res Function(_$_LoadingDefault) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_LoadingDefault implements _LoadingDefault {
  _$_LoadingDefault();

  @override
  String toString() {
    return 'HomeCubitState.loadingDefault()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_LoadingDefault);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingDefault,
    required TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)
        main,
    required TResult Function(double percentage) computing,
    required TResult Function(Image image) goToResults,
  }) {
    return loadingDefault();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingDefault,
    TResult? Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult? Function(double percentage)? computing,
    TResult? Function(Image image)? goToResults,
  }) {
    return loadingDefault?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingDefault,
    TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult Function(double percentage)? computing,
    TResult Function(Image image)? goToResults,
    required TResult orElse(),
  }) {
    if (loadingDefault != null) {
      return loadingDefault();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingDefault value) loadingDefault,
    required TResult Function(_Main value) main,
    required TResult Function(_Computing value) computing,
    required TResult Function(_GoToResults value) goToResults,
  }) {
    return loadingDefault(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadingDefault value)? loadingDefault,
    TResult? Function(_Main value)? main,
    TResult? Function(_Computing value)? computing,
    TResult? Function(_GoToResults value)? goToResults,
  }) {
    return loadingDefault?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingDefault value)? loadingDefault,
    TResult Function(_Main value)? main,
    TResult Function(_Computing value)? computing,
    TResult Function(_GoToResults value)? goToResults,
    required TResult orElse(),
  }) {
    if (loadingDefault != null) {
      return loadingDefault(this);
    }
    return orElse();
  }
}

abstract class _LoadingDefault implements HomeCubitState {
  factory _LoadingDefault() = _$_LoadingDefault;
}

/// @nodoc
abstract class _$$_MainCopyWith<$Res> {
  factory _$$_MainCopyWith(_$_Main value, $Res Function(_$_Main) then) =
      __$$_MainCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {Image image1,
      Image image2,
      bool decode1Available,
      bool decode2Available,
      bool codeAvailable,
      int codeDirection,
      int bitsToUse,
      int maxSideLength});
}

/// @nodoc
class __$$_MainCopyWithImpl<$Res>
    extends _$HomeCubitStateCopyWithImpl<$Res, _$_Main>
    implements _$$_MainCopyWith<$Res> {
  __$$_MainCopyWithImpl(_$_Main _value, $Res Function(_$_Main) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image1 = null,
    Object? image2 = null,
    Object? decode1Available = null,
    Object? decode2Available = null,
    Object? codeAvailable = null,
    Object? codeDirection = null,
    Object? bitsToUse = null,
    Object? maxSideLength = null,
  }) {
    return _then(_$_Main(
      null == image1
          ? _value.image1
          : image1 // ignore: cast_nullable_to_non_nullable
              as Image,
      null == image2
          ? _value.image2
          : image2 // ignore: cast_nullable_to_non_nullable
              as Image,
      null == decode1Available
          ? _value.decode1Available
          : decode1Available // ignore: cast_nullable_to_non_nullable
              as bool,
      null == decode2Available
          ? _value.decode2Available
          : decode2Available // ignore: cast_nullable_to_non_nullable
              as bool,
      null == codeAvailable
          ? _value.codeAvailable
          : codeAvailable // ignore: cast_nullable_to_non_nullable
              as bool,
      null == codeDirection
          ? _value.codeDirection
          : codeDirection // ignore: cast_nullable_to_non_nullable
              as int,
      null == bitsToUse
          ? _value.bitsToUse
          : bitsToUse // ignore: cast_nullable_to_non_nullable
              as int,
      null == maxSideLength
          ? _value.maxSideLength
          : maxSideLength // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Main implements _Main {
  _$_Main(
      this.image1,
      this.image2,
      this.decode1Available,
      this.decode2Available,
      this.codeAvailable,
      this.codeDirection,
      this.bitsToUse,
      this.maxSideLength);

  @override
  final Image image1;
  @override
  final Image image2;
  @override
  final bool decode1Available;
  @override
  final bool decode2Available;
  @override
  final bool codeAvailable;
  @override
  final int codeDirection;
  @override
  final int bitsToUse;
  @override
  final int maxSideLength;

  @override
  String toString() {
    return 'HomeCubitState.main(image1: $image1, image2: $image2, decode1Available: $decode1Available, decode2Available: $decode2Available, codeAvailable: $codeAvailable, codeDirection: $codeDirection, bitsToUse: $bitsToUse, maxSideLength: $maxSideLength)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Main &&
            (identical(other.image1, image1) || other.image1 == image1) &&
            (identical(other.image2, image2) || other.image2 == image2) &&
            (identical(other.decode1Available, decode1Available) ||
                other.decode1Available == decode1Available) &&
            (identical(other.decode2Available, decode2Available) ||
                other.decode2Available == decode2Available) &&
            (identical(other.codeAvailable, codeAvailable) ||
                other.codeAvailable == codeAvailable) &&
            (identical(other.codeDirection, codeDirection) ||
                other.codeDirection == codeDirection) &&
            (identical(other.bitsToUse, bitsToUse) ||
                other.bitsToUse == bitsToUse) &&
            (identical(other.maxSideLength, maxSideLength) ||
                other.maxSideLength == maxSideLength));
  }

  @override
  int get hashCode => Object.hash(runtimeType, image1, image2, decode1Available,
      decode2Available, codeAvailable, codeDirection, bitsToUse, maxSideLength);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MainCopyWith<_$_Main> get copyWith =>
      __$$_MainCopyWithImpl<_$_Main>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingDefault,
    required TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)
        main,
    required TResult Function(double percentage) computing,
    required TResult Function(Image image) goToResults,
  }) {
    return main(image1, image2, decode1Available, decode2Available,
        codeAvailable, codeDirection, bitsToUse, maxSideLength);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingDefault,
    TResult? Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult? Function(double percentage)? computing,
    TResult? Function(Image image)? goToResults,
  }) {
    return main?.call(image1, image2, decode1Available, decode2Available,
        codeAvailable, codeDirection, bitsToUse, maxSideLength);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingDefault,
    TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult Function(double percentage)? computing,
    TResult Function(Image image)? goToResults,
    required TResult orElse(),
  }) {
    if (main != null) {
      return main(image1, image2, decode1Available, decode2Available,
          codeAvailable, codeDirection, bitsToUse, maxSideLength);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingDefault value) loadingDefault,
    required TResult Function(_Main value) main,
    required TResult Function(_Computing value) computing,
    required TResult Function(_GoToResults value) goToResults,
  }) {
    return main(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadingDefault value)? loadingDefault,
    TResult? Function(_Main value)? main,
    TResult? Function(_Computing value)? computing,
    TResult? Function(_GoToResults value)? goToResults,
  }) {
    return main?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingDefault value)? loadingDefault,
    TResult Function(_Main value)? main,
    TResult Function(_Computing value)? computing,
    TResult Function(_GoToResults value)? goToResults,
    required TResult orElse(),
  }) {
    if (main != null) {
      return main(this);
    }
    return orElse();
  }
}

abstract class _Main implements HomeCubitState {
  factory _Main(
      final Image image1,
      final Image image2,
      final bool decode1Available,
      final bool decode2Available,
      final bool codeAvailable,
      final int codeDirection,
      final int bitsToUse,
      final int maxSideLength) = _$_Main;

  Image get image1;
  Image get image2;
  bool get decode1Available;
  bool get decode2Available;
  bool get codeAvailable;
  int get codeDirection;
  int get bitsToUse;
  int get maxSideLength;
  @JsonKey(ignore: true)
  _$$_MainCopyWith<_$_Main> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_ComputingCopyWith<$Res> {
  factory _$$_ComputingCopyWith(
          _$_Computing value, $Res Function(_$_Computing) then) =
      __$$_ComputingCopyWithImpl<$Res>;
  @useResult
  $Res call({double percentage});
}

/// @nodoc
class __$$_ComputingCopyWithImpl<$Res>
    extends _$HomeCubitStateCopyWithImpl<$Res, _$_Computing>
    implements _$$_ComputingCopyWith<$Res> {
  __$$_ComputingCopyWithImpl(
      _$_Computing _value, $Res Function(_$_Computing) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? percentage = null,
  }) {
    return _then(_$_Computing(
      null == percentage
          ? _value.percentage
          : percentage // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_Computing implements _Computing {
  _$_Computing(this.percentage);

  @override
  final double percentage;

  @override
  String toString() {
    return 'HomeCubitState.computing(percentage: $percentage)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Computing &&
            (identical(other.percentage, percentage) ||
                other.percentage == percentage));
  }

  @override
  int get hashCode => Object.hash(runtimeType, percentage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ComputingCopyWith<_$_Computing> get copyWith =>
      __$$_ComputingCopyWithImpl<_$_Computing>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingDefault,
    required TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)
        main,
    required TResult Function(double percentage) computing,
    required TResult Function(Image image) goToResults,
  }) {
    return computing(percentage);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingDefault,
    TResult? Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult? Function(double percentage)? computing,
    TResult? Function(Image image)? goToResults,
  }) {
    return computing?.call(percentage);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingDefault,
    TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult Function(double percentage)? computing,
    TResult Function(Image image)? goToResults,
    required TResult orElse(),
  }) {
    if (computing != null) {
      return computing(percentage);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingDefault value) loadingDefault,
    required TResult Function(_Main value) main,
    required TResult Function(_Computing value) computing,
    required TResult Function(_GoToResults value) goToResults,
  }) {
    return computing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadingDefault value)? loadingDefault,
    TResult? Function(_Main value)? main,
    TResult? Function(_Computing value)? computing,
    TResult? Function(_GoToResults value)? goToResults,
  }) {
    return computing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingDefault value)? loadingDefault,
    TResult Function(_Main value)? main,
    TResult Function(_Computing value)? computing,
    TResult Function(_GoToResults value)? goToResults,
    required TResult orElse(),
  }) {
    if (computing != null) {
      return computing(this);
    }
    return orElse();
  }
}

abstract class _Computing implements HomeCubitState {
  factory _Computing(final double percentage) = _$_Computing;

  double get percentage;
  @JsonKey(ignore: true)
  _$$_ComputingCopyWith<_$_Computing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_GoToResultsCopyWith<$Res> {
  factory _$$_GoToResultsCopyWith(
          _$_GoToResults value, $Res Function(_$_GoToResults) then) =
      __$$_GoToResultsCopyWithImpl<$Res>;
  @useResult
  $Res call({Image image});
}

/// @nodoc
class __$$_GoToResultsCopyWithImpl<$Res>
    extends _$HomeCubitStateCopyWithImpl<$Res, _$_GoToResults>
    implements _$$_GoToResultsCopyWith<$Res> {
  __$$_GoToResultsCopyWithImpl(
      _$_GoToResults _value, $Res Function(_$_GoToResults) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
  }) {
    return _then(_$_GoToResults(
      null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as Image,
    ));
  }
}

/// @nodoc

class _$_GoToResults implements _GoToResults {
  _$_GoToResults(this.image);

  @override
  final Image image;

  @override
  String toString() {
    return 'HomeCubitState.goToResults(image: $image)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GoToResults &&
            (identical(other.image, image) || other.image == image));
  }

  @override
  int get hashCode => Object.hash(runtimeType, image);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_GoToResultsCopyWith<_$_GoToResults> get copyWith =>
      __$$_GoToResultsCopyWithImpl<_$_GoToResults>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadingDefault,
    required TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)
        main,
    required TResult Function(double percentage) computing,
    required TResult Function(Image image) goToResults,
  }) {
    return goToResults(image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadingDefault,
    TResult? Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult? Function(double percentage)? computing,
    TResult? Function(Image image)? goToResults,
  }) {
    return goToResults?.call(image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadingDefault,
    TResult Function(
            Image image1,
            Image image2,
            bool decode1Available,
            bool decode2Available,
            bool codeAvailable,
            int codeDirection,
            int bitsToUse,
            int maxSideLength)?
        main,
    TResult Function(double percentage)? computing,
    TResult Function(Image image)? goToResults,
    required TResult orElse(),
  }) {
    if (goToResults != null) {
      return goToResults(image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadingDefault value) loadingDefault,
    required TResult Function(_Main value) main,
    required TResult Function(_Computing value) computing,
    required TResult Function(_GoToResults value) goToResults,
  }) {
    return goToResults(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadingDefault value)? loadingDefault,
    TResult? Function(_Main value)? main,
    TResult? Function(_Computing value)? computing,
    TResult? Function(_GoToResults value)? goToResults,
  }) {
    return goToResults?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadingDefault value)? loadingDefault,
    TResult Function(_Main value)? main,
    TResult Function(_Computing value)? computing,
    TResult Function(_GoToResults value)? goToResults,
    required TResult orElse(),
  }) {
    if (goToResults != null) {
      return goToResults(this);
    }
    return orElse();
  }
}

abstract class _GoToResults implements HomeCubitState {
  factory _GoToResults(final Image image) = _$_GoToResults;

  Image get image;
  @JsonKey(ignore: true)
  _$$_GoToResultsCopyWith<_$_GoToResults> get copyWith =>
      throw _privateConstructorUsedError;
}
